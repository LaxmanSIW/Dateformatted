function main(workbook: ExcelScript.Workbook): string {
  // Get the active sheet
  const sheet: ExcelScript.Worksheet = workbook.getActiveWorksheet();
  
  // Get the used range
  const usedRange: ExcelScript.Range | undefined = sheet.getUsedRange();
  if (!usedRange) {
    return "<html><body><p>No data found in sheet</p></body></html>";
  }

  const rowCount: number = usedRange.getRowCount();
  const colCount: number = usedRange.getColumnCount();
  const startRow: number = usedRange.getRowIndex();
  const startCol: number = usedRange.getColumnIndex();

  // Track merged cells to skip them later
  const mergedCells: boolean[][] = [];
  for (let i: number = 0; i < rowCount; i++) {
    mergedCells[i] = [];
    for (let j: number = 0; j < colCount; j++) {
      mergedCells[i][j] = false;
    }
  }

  // Get all merged ranges in the used range
  const mergedRanges: ExcelScript.Range[] = usedRange.getMergedAreas();
  const mergedData: Array<{
    rowStart: number;
    colStart: number;
    rowSpan: number;
    colSpan: number;
  }> = [];

  // Process merged ranges
  for (let i: number = 0; i < mergedRanges.length; i++) {
    const range: ExcelScript.Range = mergedRanges[i];
    const rowIdx: number = range.getRowIndex() - startRow;
    const colIdx: number = range.getColumnIndex() - startCol;
    const rows: number = range.getRowCount();
    const cols: number = range.getColumnCount();
    
    mergedData.push({
      rowStart: rowIdx,
      colStart: colIdx,
      rowSpan: rows,
      colSpan: cols
    });

    // Mark cells as merged
    for (let r: number = rowIdx; r < rowIdx + rows; r++) {
      for (let c: number = colIdx; c < colIdx + cols; c++) {
        if (r !== rowIdx || c !== colIdx) {
          mergedCells[r][c] = true;
        }
      }
    }
  }

  // Build HTML
  let html: string = '<!DOCTYPE html><html><head><meta charset="UTF-8"><style>';
  html += 'table{border-collapse:collapse;font-family:Calibri,sans-serif;}';
  html += 'td{border:1px solid #d0d0d0;padding:2px 4px;white-space:pre-wrap;word-wrap:break-word;}';
  html += '</style></head><body><table>';

  // Process each row
  for (let r: number = 0; r < rowCount; r++) {
    const rowRange: ExcelScript.Range = sheet.getRangeByIndexes(startRow + r, startCol, 1, colCount);
    const rowHeight: number = rowRange.getRowHeight();
    
    html += '<tr style="height:' + rowHeight + 'px;">';

    for (let c: number = 0; c < colCount; c++) {
      // Skip if this cell is part of a merge (but not the starting cell)
      if (mergedCells[r][c]) {
        continue;
      }

      const cell: ExcelScript.Range = sheet.getCell(startRow + r, startCol + c);
      const format: ExcelScript.RangeFormat = cell.getFormat();
      
      // Get cell dimensions
      const colWidth: number = sheet.getRangeByIndexes(startRow, startCol + c, 1, 1).getColumnWidth();

      // Check if this cell is the start of a merged range
      let rowSpan: number = 1;
      let colSpan: number = 1;
      for (let m: number = 0; m < mergedData.length; m++) {
        const merge = mergedData[m];
        if (merge.rowStart === r && merge.colStart === c) {
          rowSpan = merge.rowSpan;
          colSpan = merge.colSpan;
          break;
        }
      }

      // Build cell style
      let style: string = 'width:' + colWidth + 'px;';
      
      // Background color
      const fill: ExcelScript.RangeFill = format.getFill();
      const bgColor: string = fill.getColor();
      if (bgColor && bgColor.toUpperCase() !== '#FFFFFF') {
        style += 'background-color:' + bgColor + ';';
      }

      // Font properties
      const font: ExcelScript.RangeFont = format.getFont();
      const fontSize: number = font.getSize();
      const fontColor: string = font.getColor();
      const fontName: string = font.getName();
      const isBold: boolean = font.getBold();
      const isItalic: boolean = font.getItalic();
      const underline: string = font.getUnderline();
      
      style += 'font-size:' + fontSize + 'pt;';
      style += 'color:' + fontColor + ';';
      style += 'font-family:' + fontName + ';';
      
      if (isBold) {
        style += 'font-weight:bold;';
      }
      if (isItalic) {
        style += 'font-style:italic;';
      }
      if (underline !== 'None') {
        style += 'text-decoration:underline;';
      }

      // Horizontal alignment
      const hAlign: string = format.getHorizontalAlignment();
      if (hAlign === 'Center') {
        style += 'text-align:center;';
      } else if (hAlign === 'Right') {
        style += 'text-align:right;';
      } else if (hAlign === 'Left') {
        style += 'text-align:left;';
      }

      // Vertical alignment
      const vAlign: string = format.getVerticalAlignment();
      if (vAlign === 'Center') {
        style += 'vertical-align:middle;';
      } else if (vAlign === 'Top') {
        style += 'vertical-align:top;';
      } else if (vAlign === 'Bottom') {
        style += 'vertical-align:bottom;';
      }

      // Borders
      const borderTop: ExcelScript.RangeBorder = format.getRangeBorder('EdgeTop');
      const borderTopStyle: string = borderTop.getStyle();
      if (borderTopStyle !== 'None') {
        const borderTopColor: string = borderTop.getColor();
        style += 'border-top:1px solid ' + borderTopColor + ';';
      }
      
      const borderRight: ExcelScript.RangeBorder = format.getRangeBorder('EdgeRight');
      const borderRightStyle: string = borderRight.getStyle();
      if (borderRightStyle !== 'None') {
        const borderRightColor: string = borderRight.getColor();
        style += 'border-right:1px solid ' + borderRightColor + ';';
      }
      
      const borderBottom: ExcelScript.RangeBorder = format.getRangeBorder('EdgeBottom');
      const borderBottomStyle: string = borderBottom.getStyle();
      if (borderBottomStyle !== 'None') {
        const borderBottomColor: string = borderBottom.getColor();
        style += 'border-bottom:1px solid ' + borderBottomColor + ';';
      }
      
      const borderLeft: ExcelScript.RangeBorder = format.getRangeBorder('EdgeLeft');
      const borderLeftStyle: string = borderLeft.getStyle();
      if (borderLeftStyle !== 'None') {
        const borderLeftColor: string = borderLeft.getColor();
        style += 'border-left:1px solid ' + borderLeftColor + ';';
      }

      // Text wrapping
      const isWrapped: boolean = format.getWrapText();
      if (isWrapped) {
        style += 'white-space:pre-wrap;';
      } else {
        style += 'white-space:nowrap;overflow:hidden;';
      }

      // Get cell value (displayed text)
      const displayValue: string = cell.getText();

      // Build cell tag
      let cellTag: string = '<td';
      if (rowSpan > 1) {
        cellTag += ' rowspan="' + rowSpan + '"';
      }
      if (colSpan > 1) {
        cellTag += ' colspan="' + colSpan + '"';
      }
      cellTag += ' style="' + style + '">';
      
      // Escape HTML special characters
      let cellContent: string = displayValue
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
      
      cellTag += cellContent + '</td>';
      html += cellTag;
    }

    html += '</tr>';
  }

  html += '</table></body></html>';
  
  return html;
}
