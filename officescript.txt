function main(workbook: ExcelScript.Workbook): string {
  // Get the active sheet
  const sheet = workbook.getActiveWorksheet();
  
  // Get the used range
  const usedRange = sheet.getUsedRange();
  if (!usedRange) {
    return "<html><body><p>No data found in sheet</p></body></html>";
  }

  const rowCount = usedRange.getRowCount();
  const colCount = usedRange.getColumnCount();
  const startRow = usedRange.getRowIndex();
  const startCol = usedRange.getColumnIndex();

  // Track merged cells to skip them later
  const mergedCells: boolean[][] = [];
  for (let i = 0; i < rowCount; i++) {
    mergedCells[i] = [];
    for (let j = 0; j < colCount; j++) {
      mergedCells[i][j] = false;
    }
  }

  // Get all merged ranges in the used range
  const mergedRanges = usedRange.getMergedAreas();
  const mergedData: Array<{
    rowStart: number;
    colStart: number;
    rowSpan: number;
    colSpan: number;
  }> = [];

  mergedRanges.forEach(range => {
    const addr = range.getAddress();
    const rowIdx = range.getRowIndex() - startRow;
    const colIdx = range.getColumnIndex() - startCol;
    const rows = range.getRowCount();
    const cols = range.getColumnCount();
    
    mergedData.push({
      rowStart: rowIdx,
      colStart: colIdx,
      rowSpan: rows,
      colSpan: cols
    });

    // Mark cells as merged
    for (let r = rowIdx; r < rowIdx + rows; r++) {
      for (let c = colIdx; c < colIdx + cols; c++) {
        if (r !== rowIdx || c !== colIdx) {
          mergedCells[r][c] = true;
        }
      }
    }
  });

  // Build HTML
  let html = '<!DOCTYPE html><html><head><meta charset="UTF-8"><style>';
  html += 'table{border-collapse:collapse;font-family:Calibri,sans-serif;}';
  html += 'td{border:1px solid #d0d0d0;padding:2px 4px;white-space:pre-wrap;word-wrap:break-word;}';
  html += '</style></head><body><table>';

  // Process each row
  for (let r = 0; r < rowCount; r++) {
    const rowRange = sheet.getRangeByIndexes(startRow + r, startCol, 1, colCount);
    const rowHeight = rowRange.getRowHeight();
    
    html += '<tr style="height:' + rowHeight + 'px;">';

    for (let c = 0; c < colCount; c++) {
      // Skip if this cell is part of a merge (but not the starting cell)
      if (mergedCells[r][c]) {
        continue;
      }

      const cell = sheet.getCell(startRow + r, startCol + c);
      const format = cell.getFormat();
      
      // Get cell dimensions
      const colWidth = sheet.getRangeByIndexes(startRow, startCol + c, 1, 1).getColumnWidth();

      // Check if this cell is the start of a merged range
      let rowSpan = 1;
      let colSpan = 1;
      for (const merge of mergedData) {
        if (merge.rowStart === r && merge.colStart === c) {
          rowSpan = merge.rowSpan;
          colSpan = merge.colSpan;
          break;
        }
      }

      // Build cell style
      let style = 'width:' + colWidth + 'px;';
      
      // Background color
      const bgColor = format.getFill().getColor();
      if (bgColor && bgColor.toUpperCase() !== '#FFFFFF') {
        style += 'background-color:' + bgColor + ';';
      }

      // Font properties
      const font = format.getFont();
      style += 'font-size:' + font.getSize() + 'pt;';
      style += 'color:' + font.getColor() + ';';
      style += 'font-family:' + font.getName() + ';';
      
      if (font.getBold()) {
        style += 'font-weight:bold;';
      }
      if (font.getItalic()) {
        style += 'font-style:italic;';
      }
      if (font.getUnderline() !== 'None') {
        style += 'text-decoration:underline;';
      }

      // Horizontal alignment
      const hAlign = format.getHorizontalAlignment();
      if (hAlign === 'Center') {
        style += 'text-align:center;';
      } else if (hAlign === 'Right') {
        style += 'text-align:right;';
      } else if (hAlign === 'Left') {
        style += 'text-align:left;';
      }

      // Vertical alignment
      const vAlign = format.getVerticalAlignment();
      if (vAlign === 'Center') {
        style += 'vertical-align:middle;';
      } else if (vAlign === 'Top') {
        style += 'vertical-align:top;';
      } else if (vAlign === 'Bottom') {
        style += 'vertical-align:bottom;';
      }

      // Borders
      const borders = format.getRangeBorder('EdgeTop');
      if (borders.getStyle() !== 'None') {
        style += 'border-top:1px solid ' + borders.getColor() + ';';
      }
      const borderRight = format.getRangeBorder('EdgeRight');
      if (borderRight.getStyle() !== 'None') {
        style += 'border-right:1px solid ' + borderRight.getColor() + ';';
      }
      const borderBottom = format.getRangeBorder('EdgeBottom');
      if (borderBottom.getStyle() !== 'None') {
        style += 'border-bottom:1px solid ' + borderBottom.getColor() + ';';
      }
      const borderLeft = format.getRangeBorder('EdgeLeft');
      if (borderLeft.getStyle() !== 'None') {
        style += 'border-left:1px solid ' + borderLeft.getColor() + ';';
      }

      // Text wrapping
      if (format.getWrapText()) {
        style += 'white-space:pre-wrap;';
      } else {
        style += 'white-space:nowrap;overflow:hidden;';
      }

      // Get cell value (displayed text)
      const displayValue = cell.getText();

      // Build cell tag
      let cellTag = '<td';
      if (rowSpan > 1) {
        cellTag += ' rowspan="' + rowSpan + '"';
      }
      if (colSpan > 1) {
        cellTag += ' colspan="' + colSpan + '"';
      }
      cellTag += ' style="' + style + '">';
      
      // Escape HTML special characters
      let cellContent = displayValue
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;');
      
      cellTag += cellContent + '</td>';
      html += cellTag;
    }

    html += '</tr>';
  }

  html += '</table></body></html>';
  
  return html;
}
