function main(workbook: ExcelScript.Workbook): string {
  function ptToPx(pt: number) {
    return Math.round(pt * 1.3333);
  }

  const sheet = workbook.getWorksheet("Main");
  const usedRange = sheet.getUsedRange();
  if (!usedRange) return "No data found in sheet";

  const values = usedRange.getValues();
  const totalRows = values.length;
  const totalCols = values[0].length;

  const usedTopRow = usedRange.getRowIndex();
  const usedLeftCol = usedRange.getColumnIndex();

  // Batch row heights and column widths (still 1 call per row/col but unavoidable)
  const rowHeights = Array.from({ length: totalRows }, (_, r) => usedRange.getRow(r).getHeight());
  const colWidths = Array.from({ length: totalCols }, (_, c) => usedRange.getColumn(c).getWidth());

  // Batch ALL cell formatting (single call for entire usedRange)
  const props = usedRange.getCellProperties({
    format: {
      horizontalAlignment: true,
      verticalAlignment: true,
      font: { bold: true, italic: true, underline: true, size: true, name: true, color: true },
      fill: { color: true },
      borders: {
        top: { style: true, color: true },
        bottom: { style: true, color: true },
        left: { style: true, color: true },
        right: { style: true, color: true },
      },
      wrapText: true
    }
  });

  // merged map detection (unchanged logic, this is cheap)
  const mergedMap = new Map<string, {rowSpan:number,colSpan:number,isTopLeft:boolean}>();
  const mergedAreas = usedRange.getMergedAreas()?.getAreas() ?? [];
  mergedAreas.forEach(range => {
    const r0 = range.getCell(0,0).getRowIndex() - usedTopRow;
    const c0 = range.getCell(0,0).getColumnIndex() - usedLeftCol;
    const rs = range.getRowCount();
    const cs = range.getColumnCount();
    for (let r = r0; r < r0 + rs; r++) {
      for (let c = c0; c < c0 + cs; c++) {
        mergedMap.set(`${r},${c}`, {
          rowSpan: rs,
          colSpan: cs,
          isTopLeft: (r === r0 && c === c0)
        });
      }
    }
  });

  // Build HTML
  const html: string[] = [];
  html.push("<table border='0' cellspacing='0' cellpadding='0'>");

  for (let r = 0; r < totalRows; r++) {
    html.push(`<tr style="height:${ptToPx(rowHeights[r])}px">`);

    for (let c = 0; c < totalCols; c++) {

      const merge = mergedMap.get(`${r},${c}`);
      if (merge && !merge.isTopLeft) continue;

      const p = props[r][c].format;
      const style: string[] = [];

      if (p.font?.bold) style.push("font-weight:bold");
      if (p.font?.italic) style.push("font-style:italic");
      if (p.font?.underline !== "None") style.push("text-decoration:underline");
      if (p.font?.size) style.push(`font-size:${ptToPx(p.font.size)}px`);
      if (p.font?.name) style.push(`font-family:${p.font.name}`);
      if (p.font?.color) style.push(`color:${p.font.color}`);
      if (p.fill?.color) style.push(`background:${p.fill.color}`);
      if (p.horizontalAlignment) style.push(`text-align:${p.horizontalAlignment.toLowerCase()}`);
      if (p.verticalAlignment) style.push(`vertical-align:${p.verticalAlignment.toLowerCase()}`);
      if (p.wrapText) style.push("white-space:normal");
      style.push(`width:${ptToPx(colWidths[c])}px`);

      const b = p.borders;
      if (b?.top?.style !== "None") style.push(`border-top:1px solid ${b.top.color}`);
      if (b?.right?.style !== "None") style.push(`border-right:1px solid ${b.right.color}`);
      if (b?.bottom?.style !== "None") style.push(`border-bottom:1px solid ${b.bottom.color}`);
      if (b?.left?.style !== "None") style.push(`border-left:1px solid ${b.left.color}`);

      const span = merge ? ` rowspan="${merge.rowSpan}" colspan="${merge.colSpan}"` : "";
      html.push(`<td${span} style="${style.join(";")}">${values[r][c] ?? ""}</td>`);
    }

    html.push("</tr>");
  }

  html.push("</table>");
  return html.join("");
}
